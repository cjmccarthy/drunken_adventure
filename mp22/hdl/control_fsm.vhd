-- VHDL Entity ece411.Control.interface
--
-- Created:
--          by - mccart18.ews (gelib-057-33.ews.illinois.edu)
--          at - 04:31:03 02/20/13
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2012.1 (Build 6)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.NUMERIC_STD.all;

LIBRARY ece411;
USE ece411.LC3b_types.all;

ENTITY Control IS
   PORT( 
      CheckN      : IN     std_logic;
      CheckP      : IN     std_logic;
      CheckZ      : IN     std_logic;
      IR11        : IN     std_logic;
      IR4         : IN     std_logic;
      IR5         : IN     std_logic;
      MRESP_H     : IN     std_logic;
      OFFb        : IN     std_logic;
      Opcode      : IN     LC3b_opcode;
      RESET_L     : IN     std_logic;
      START_H     : IN     std_logic;
      clk         : IN     std_logic;
      n           : IN     std_logic;
      p           : IN     std_logic;
      z           : IN     std_logic;
      ADDRMux1Sel : OUT    std_logic;
      ADDRMux2Sel : OUT    LC3b_4mux_sel;
      ADJ6MuxSel  : OUT    std_logic;
      ALUMuxSel   : OUT    std_logic;
      ALUop       : OUT    LC3b_aluop;
      DRMuxSel    : OUT    std_logic;
      LoadIR      : OUT    std_logic;
      LoadMAR     : OUT    std_logic;
      LoadMDR     : OUT    std_logic;
      LoadNZP     : OUT    std_logic;
      LoadPC      : OUT    std_logic;
      MARMuxSel   : OUT    LC3b_4mux_sel;
      MDRMuxSel   : OUT    std_logic;
      MREAD_L     : OUT    std_logic;
      MWRITEH_L   : OUT    std_logic;
      MWRITEL_L   : OUT    std_logic;
      PCMuxSel    : OUT    LC3b_4mux_sel;
      RFMuxSel    : OUT    LC3b_4mux_sel;
      RegWrite    : OUT    std_logic;
      StoreSR     : OUT    std_logic;
      immMuxSel   : OUT    LC3b_4mux_sel
   );

-- Declarations

END Control ;

--
-- VHDL Architecture ece411.Control.fsm
--
-- Created:
--          by - mccart18.ews (gelib-057-33.ews.illinois.edu)
--          at - 04:31:03 02/20/13
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2012.1 (Build 6)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.NUMERIC_STD.all;

LIBRARY ece411;
USE ece411.LC3b_types.all;
 
ARCHITECTURE fsm OF Control IS

   TYPE STATE_TYPE IS (
      Reset,
      L_NOT,
      Decode,
      BR1,
      BR2,
      IF1,
      IF2,
      IF3,
      CalcADDR,
      ST1,
      LD1,
      ST2,
      LD2,
      JMP_RET,
      LEA,
      JSR_JSRR,
      JSR,
      JSRR,
      TRAP,
      TRAP1,
      ADD_imm,
      ADD_reg,
      AND_imm,
      AND_reg,
      L_SLL,
      L_SR,
      L_SRL,
      L_SRA,
      CalcADDR1,
      ST3,
      LD3,
      STB_H,
      LD4,
      STB_L,
      CalcADDRI,
      LD5_I,
      LD6_I,
      ST4,
      ST5,
      LD7,
      LD8,
      STB_H2
   );
 
   -- Declare current and next state signals
   SIGNAL current_state : STATE_TYPE;
   SIGNAL next_state : STATE_TYPE;

BEGIN

   -----------------------------------------------------------------
   clocked_proc : PROCESS ( 
      clk,
      RESET_L
   )
   -----------------------------------------------------------------
   BEGIN
      IF (RESET_L = '0') THEN
         current_state <= Reset;
      ELSIF (clk'EVENT AND clk = '1') THEN
         current_state <= next_state;
      END IF;
   END PROCESS clocked_proc;
 
   -----------------------------------------------------------------
   nextstate_proc : PROCESS ( 
      CheckN,
      CheckP,
      CheckZ,
      IR11,
      IR4,
      IR5,
      MRESP_H,
      OFFb,
      Opcode,
      START_H,
      current_state,
      n,
      p,
      z
   )
   -----------------------------------------------------------------
   BEGIN
      CASE current_state IS
         WHEN Reset => 
            IF (START_H = '1') THEN 
               next_state <= IF1;
            ELSE
               next_state <= Reset;
            END IF;
         WHEN L_NOT => 
            next_state <= IF1;
         WHEN Decode => 
            IF (Opcode = op_not) THEN 
               next_state <= L_NOT;
            ELSIF ((Opcode = op_ldr) OR
                   (Opcode = op_str)) THEN 
               next_state <= CalcADDR;
            ELSIF (Opcode = op_br) THEN 
               next_state <= BR1;
            ELSIF (Opcode = op_jmp) THEN 
               next_state <= JMP_RET;
            ELSIF (Opcode = op_lea) THEN 
               next_state <= LEA;
            ELSIF (Opcode = op_jsr) THEN 
               next_state <= JSR_JSRR;
            ELSIF (Opcode = op_trap) THEN 
               next_state <= TRAP;
            ELSIF ((Opcode = op_add) AND (IR5 = '1')) THEN 
               next_state <= ADD_imm;
            ELSIF (Opcode = op_add) THEN 
               next_state <= ADD_reg;
            ELSIF ((Opcode = op_shf) AND (IR4 = '0')) THEN 
               next_state <= L_SLL;
            ELSIF (Opcode = op_shf) THEN 
               next_state <= L_SR;
            ELSIF ((Opcode = op_and) AND (IR5 = '1')) THEN 
               next_state <= AND_imm;
            ELSIF (Opcode = op_and) THEN 
               next_state <= AND_reg;
            ELSIF ((Opcode = op_ldb) OR
                   (Opcode = op_stb)) THEN 
               next_state <= CalcADDR1;
            ELSIF ((Opcode = op_sti) OR
                   (Opcode = op_ldi)) THEN 
               next_state <= CalcADDRI;
            ELSE
               next_state <= IF1;
            END IF;
         WHEN BR1 => 
            IF (( (n AND CheckN ) OR
                (  p AND CheckP ) OR
                (  z AND CheckZ ) ) = '1') THEN 
               next_state <= BR2;
            ELSE
               next_state <= IF1;
            END IF;
         WHEN BR2 => 
            next_state <= IF1;
         WHEN IF1 => 
            next_state <= IF2;
         WHEN IF2 => 
            IF (MRESP_H = '1') THEN 
               next_state <= IF3;
            ELSE
               next_state <= IF2;
            END IF;
         WHEN IF3 => 
            next_state <= Decode;
         WHEN CalcADDR => 
            IF (Opcode = op_str) THEN 
               next_state <= ST1;
            ELSIF (Opcode = op_ldr) THEN 
               next_state <= LD1;
            ELSE
               next_state <= CalcADDR;
            END IF;
         WHEN ST1 => 
            next_state <= ST2;
         WHEN LD1 => 
            IF (MRESP_H = '1') THEN 
               next_state <= LD2;
            ELSE
               next_state <= LD1;
            END IF;
         WHEN ST2 => 
            IF (MRESP_H = '1') THEN 
               next_state <= IF1;
            ELSE
               next_state <= ST2;
            END IF;
         WHEN LD2 => 
            next_state <= IF1;
         WHEN JMP_RET => 
            next_state <= IF1;
         WHEN LEA => 
            next_state <= IF1;
         WHEN JSR_JSRR => 
            IF (IR11 = '1') THEN 
               next_state <= JSR;
            ELSE
               next_state <= JSRR;
            END IF;
         WHEN JSR => 
            next_state <= IF1;
         WHEN JSRR => 
            next_state <= IF1;
         WHEN TRAP => 
            next_state <= TRAP1;
         WHEN TRAP1 => 
            next_state <= IF1;
         WHEN ADD_imm => 
            next_state <= IF1;
         WHEN ADD_reg => 
            next_state <= IF1;
         WHEN AND_imm => 
            next_state <= IF1;
         WHEN AND_reg => 
            next_state <= IF1;
         WHEN L_SLL => 
            next_state <= IF1;
         WHEN L_SR => 
            IF (IR5 = '0') THEN 
               next_state <= L_SRL;
            ELSE
               next_state <= L_SRA;
            END IF;
         WHEN L_SRL => 
            next_state <= IF1;
         WHEN L_SRA => 
            next_state <= IF1;
         WHEN CalcADDR1 => 
            IF (Opcode = op_stb) THEN 
               next_state <= ST3;
            ELSIF (Opcode = op_ldb) THEN 
               next_state <= LD3;
            ELSE
               next_state <= CalcADDR1;
            END IF;
         WHEN ST3 => 
            IF (OFFb = '1') THEN 
               next_state <= STB_H;
            ELSE
               next_state <= STB_L;
            END IF;
         WHEN LD3 => 
            IF (MRESP_H = '1') THEN 
               next_state <= LD4;
            ELSE
               next_state <= LD3;
            END IF;
         WHEN STB_H => 
            next_state <= STB_H2;
         WHEN LD4 => 
            next_state <= IF1;
         WHEN STB_L => 
            IF (MRESP_H = '1') THEN 
               next_state <= IF1;
            ELSE
               next_state <= STB_L;
            END IF;
         WHEN CalcADDRI => 
            next_state <= LD5_I;
         WHEN LD5_I => 
            IF (MRESP_H = '1') THEN 
               next_state <= LD6_I;
            ELSE
               next_state <= LD5_I;
            END IF;
         WHEN LD6_I => 
            IF (Opcode = op_sti) THEN 
               next_state <= ST4;
            ELSIF (Opcode = op_ldi) THEN 
               next_state <= LD7;
            ELSE
               next_state <= LD6_I;
            END IF;
         WHEN ST4 => 
            next_state <= ST5;
         WHEN ST5 => 
            IF (MRESP_H = '1') THEN 
               next_state <= IF1;
            ELSE
               next_state <= ST5;
            END IF;
         WHEN LD7 => 
            IF (MRESP_H = '1') THEN 
               next_state <= LD8;
            ELSE
               next_state <= LD7;
            END IF;
         WHEN LD8 => 
            next_state <= IF1;
         WHEN STB_H2 => 
            IF (MRESP_H = '1') THEN 
               next_state <= IF1;
            ELSE
               next_state <= STB_H2;
            END IF;
         WHEN OTHERS =>
            next_state <= Reset;
      END CASE;
   END PROCESS nextstate_proc;
 
   -----------------------------------------------------------------
   output_proc : PROCESS ( 
      current_state
   )
   -----------------------------------------------------------------
   BEGIN
      -- Default Assignment
      ADDRMux1Sel <= '0';
      ADDRMux2Sel <= "00";
      ADJ6MuxSel <= '0';
      ALUMuxSel <= '0';
      ALUop <= "000";
      DRMuxSel <= '0';
      LoadIR <= '0';
      LoadMAR <= '0';
      LoadMDR <= '0';
      LoadNZP <= '0';
      LoadPC <= '0';
      MARMuxSel <= "00";
      MDRMuxSel <= '0';
      MREAD_L <= '1';
      MWRITEH_L <= '1';
      MWRITEL_L <= '1';
      PCMuxSel <= "00";
      RFMuxSel <= "00";
      RegWrite <= '0';
      StoreSR <= '1';
      immMuxSel <= "00";

      -- Combined Actions
      CASE current_state IS
         WHEN L_NOT => 
            ALUop <= alu_not;
            RegWrite <= '1';
            LoadNZP <= '1';
            RFMuxSel <= "01";
         WHEN BR2 => 
            ADDRMux2Sel <= "01";
            ADDRMux1Sel <= '0';
            PCMuxSel <= "01";
            LoadPC <= '1';
         WHEN IF1 => 
            LoadMAR <= '1' ;
            LoadPC <= '1' ;
         WHEN IF2 => 
            LoadMDR <= '1' ;
            MREAD_L <= '0' after 6 ns;
         WHEN IF3 => 
            LoadIR <= '1';
         WHEN CalcADDR => 
            ALUMuxSel <= '1';
            ALUop <= alu_add;
            MARMuxSel <= "01";
            LoadMAR <= '1';
         WHEN ST1 => 
            StoreSR <= '0';
            ALUop <= alu_pass;
            LoadMDR <= '1';
            MDRMuxSel <= '1';
         WHEN LD1 => 
            LoadMDR <= '1';
            MREAD_L <= '0' after 6ns;
         WHEN ST2 => 
            MWRITEL_L <= '0' after 6ns;
            MWRITEH_L <= '0' after 6ns;
         WHEN LD2 => 
            RegWrite <= '1';
            LoadNZP <= '1';
         WHEN JMP_RET => 
            ADDRMux2Sel <= "11";
            ADDRMux1Sel <= '1';
            PCMuxSel <= "01";
            StoreSR <= '1';
            LoadPC <= '1';
         WHEN LEA => 
            RegWrite <= '1';
            RFMuxSel <= "10";
            ADDRMux1Sel <= '0';
            ADDRMux2Sel <= "01";
            PCMuxSel <= "01";
            StoreSR <= '0';
            LoadNZP <= '1';
         WHEN JSR_JSRR => 
            DRMuxSel <= '1';
            ADDRMux1Sel <= '0';
            ADDRMux2Sel <= "11";
            PCMuxSel <= "01";
            RFMuxSel <= "10";
            RegWrite <= '1';
         WHEN JSR => 
            ADDRMux2Sel <= "00";
            ADDRMux1Sel <= '0';
            PCMuxSel <= "01";
            LoadPC <= '1';
         WHEN JSRR => 
            ADDRMux2Sel <= "11";
            ADDRMux1Sel <= '1';
            PCMuxSel <= "01";
            StoreSR <= '1';
            LoadPC <= '1';
         WHEN TRAP => 
            DRMuxSel <= '1';
            ADDRMux1Sel <= '0';
            ADDRMux2Sel <= "11";
            PCMuxSel <= "01";
            RFMuxSEl <= "10";
            RegWrite <= '1';
         WHEN TRAP1 => 
            PCMuxSel <= "11";
            LoadPC <= '1';
         WHEN ADD_imm => 
            ALUop <= alu_add;
            RegWrite <= '1';
            LoadNZP <= '1';
            RFMuxSel <= "01";
            immMuxSel <= "01";
            ALUMuxSel <= '1';
         WHEN ADD_reg => 
            ALUop <= alu_add;
            RegWrite <= '1';
            LoadNZP <= '1';
            RFMuxSel <= "01";
            immMuxSel <= "00";
            ALUMuxSel <= '0';
         WHEN AND_imm => 
            ALUop <= alu_and;
            RegWrite <= '1';
            LoadNZP <= '1';
            RFMuxSel <= "01";
            immMuxSel <= "01";
            ALUMuxSel <= '1';
         WHEN AND_reg => 
            ALUop <= alu_and;
            RegWrite <= '1';
            LoadNZP <= '1';
            RFMuxSel <= "01";
            immMuxSel <= "00";
            ALUMuxSel <= '0';
         WHEN L_SLL => 
            ALUop <= alu_sll;
            RegWrite <= '1';
            LoadNZp <= '1';
            RFMuxSel <= "01";
            immMuxSel <= "10";
            ALUMuxSel <= '1';
         WHEN L_SRL => 
            ALUop <= alu_srl;
            RegWrite <= '1';
            LoadNZP <= '1';
            RFMuxSel <= "01";
            immMuxSel <= "10";
            ALUMuxSel <= '1';
         WHEN L_SRA => 
            ALUop <= alu_sra;
            RegWrite <= '1';
            LoadNZP <= '1';
            RFMuxSel <= "01";
            immMuxSel <= "10";
            ALUMuxSel <= '1';
         WHEN CalcADDR1 => 
            ALUMuxSel <= '1';
            ADJ6MuxSel <= '1';
            ALUop <= alu_add;
            MARMuxSel <= "01";
            LoadMAR <= '1';
         WHEN ST3 => 
            StoreSR <= '0';
            ALUop <= alu_pass;
            LoadMDR <= '1';
            MDRMuxSel <= '1';
         WHEN LD3 => 
            LoadMDR <= '1';
            MREAD_L <= '0' after 6ns;
         WHEN STB_H => 
            StoreSR <= '0';
            ALUop <= alu_sll;
            LoadMDR <= '1';
            MDRMuxSel <= '1';
            ALUMuxSel <= '1';
            immMuxSel <= "11";
         WHEN LD4 => 
            RFMuxSel <= "11";
            RegWrite <= '1';
            LoadNZP <= '1';
         WHEN STB_L => 
            MWRITEL_L <= '0' after 6ns;
         WHEN CalcADDRI => 
            ALUMuxSel <= '1';
            ALUop <= alu_add;
            MARMuxSel <= "01";
            LoadMAR <= '1';
         WHEN LD5_I => 
            LoadMDR <= '1';
            MREAD_L <= '0' after 6ns;
         WHEN LD6_I => 
            MARMuxSel <= "10";
            LoadMAR <= '1';
         WHEN ST4 => 
            StoreSR <= '0';
            ALUop <= alu_pass;
            LoadMDR <= '1';
            MDRMuxSel <= '1';
         WHEN ST5 => 
            MWRITEL_L <= '0' after 6ns;
            MWRITEH_L <= '0' after 6ns;
         WHEN LD7 => 
            LoadMDR <= '1';
            MREAD_L <= '0' after 6ns;
         WHEN LD8 => 
            RegWrite <= '1';
            LoadNZP <= '1';
         WHEN STB_H2 => 
            MWRITEH_L <= '0' after 6ns;
         WHEN OTHERS =>
            NULL;
      END CASE;
   END PROCESS output_proc;
 
END fsm;
